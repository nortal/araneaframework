<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3CR3//EN"
"../../support/docbook-dtd/docbookx.dtd">
<!--
  Copyright 2006 Webmedia Group Ltd.
 
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
   http://www.apache.org/licenses/LICENSE-2.0
 
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<article>
  <articleinfo>
    <title>Aranea Tutorial</title>

    <titleabbrev>Aranea Tutorial</titleabbrev>

    <authorgroup>
      <author>
        <firstname>Taimo</firstname>

        <surname>Peelo</surname>
      </author>

      <author>
        <firstname>Jevgeni</firstname>

        <surname>Kabanov</surname>
      </author>
    </authorgroup>
  </articleinfo>

  <!-- INTRO. WHY/WHAT FOR THIS TUTORIAL IS FOR -->

  <sect1>
    <title>What's in the tutorial?</title>

    <para>Toy application built on Aranea framework is dissected and its inner
    workings explained. Tutorial is meant as quick-dive into practical usage
    of Aranea. For more thorough understanding, additional reading of Aranea
    Reference Manual is recommended. More theoretically inclined readers might
    also want to take a look at the technical paper, which briefly describes
    the inner workings of Aranea. For more basic "Hello world" intro, see
    <emphasis>Aranea Introduction</emphasis>.</para>

    <para>We try to present this tutorial in as clear and as beginner-friendly
    way as possible. Our goal is to present material that would be
    understandable on conceptual level, even to people who have very little
    experience building JEE web applications.</para>

    <para>This tutorial is a work that will always need improvement—comments,
    suggestions and critique should be sent to <ulink
    url="mailto:team@araneaframework.org?subject=Comments on Aranea tutorial">team@araneaframework.org</ulink>.</para>
  </sect1>

  <sect1 id="running-examples">
    <title>Running Examples</title>

    <para>The rest of the tutorial will deal with the example application
    found in <literal>examples/main</literal> subdirectory in the Aranea
    distribution. It depends on resources and class from
    <literal>examples/common</literal>.</para>

    <para>When using full source distribution, <literal>ant
    build-all</literal> in the topmost distribution directory will build
    almost everything, including all that is necessary for examples
    (<literal>examples/common</literal>). To actually run examples change
    directory to <literal>examples/</literal> any subdirectory
    (<literal>main</literal> for toy application) and give command
    <literal>ant run-app</literal>. For main example
    (<literal>examples/main</literal>), embedded in-memory database should be
    started first (otherwise some parts of the sample application will not
    function). Database is started with a command <literal>ant
    run-database</literal> in the <literal>examples/main</literal>
    directory.</para>

    <para>To test a running example, point your browser to <ulink
    url="http://localhost:2000/">http://localhost:2000/</ulink>.</para>
  </sect1>

  <sect1>
    <title>Configuring Aranea Web Applications</title>

    <para>Deployment descriptors are a part of every JEE web application.
    Standard deployment descriptor used for Aranea web applications is quite
    basic, usually it just defines one Aranea dispatcher servlet and maps it
    to a particular URL path: <programlisting role="xml">&lt;servlet&gt;
  &lt;servlet-name&gt;araneaServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.araneaframework.integration.spring.AraneaSpringDispatcherServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;araneaServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/main/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting> in case of framework main example
    this is <literal>/main</literal>. There is also a Aranea specific session
    listener that takes over some session cleanup functions.</para>

    <programlisting role="xml">&lt;listener&gt;
  &lt;listener-class&gt;
    org.araneaframework.http.core.StandardSessionListener
  &lt;/listener-class&gt;
&lt;/listener&gt;</programlisting>

    <para>We use here Spring to configure Aranea starting widget via the
    <literal>/WEB-INF/aranea-conf.xml</literal> configuration file. Spring
    configuration gives a lot of power to extend or override framework modules
    when needed, but in this simple case default module assembly is
    sufficient.</para>

    <programlisting role="xml">&lt;beans&gt;
  &lt;bean id="araneaApplicationStart" 
    class="org.araneaframework.example.main.web.LoginWidget"  
    singleton="false"/&gt;
&lt;/beans&gt;</programlisting>
  </sect1>

  <sect1>
    <title>Main Example</title>

    <para>Following will describe creation of our main example. It would be
    good to get acquainted with it before proceeding further (see <xref
    linkend="running-examples" /> for instructions on how to get examples to
    run). The main example's goal is to demonstrate a working Aranea web
    application that makes use of most often-used Aranea features.</para>

      <mediaobject id="templateAppInAction" xreflabel="templateApp-in-action">
        <imageobject>
          <imagedata align="center"
                     fileref="images/templateApp-screen-small.png"
                     format="PNG" />
        </imageobject>

        <caption align="top">TemplateApp in action.</caption>
    </mediaobject>

    <sect2>
      <title>Dependencies</title>

      <para>Aranea webapp depends on a bunch of libraries that should all go
      under webapp's <literal>WEB-INF/lib/</literal> directory. Dependencies
      are included in the distributions <literal>lib</literal> directory, see
      the <literal>lib/Readme.txt</literal> for purpose of these
      libraries.</para>

      <para>In addition Aranea main example uses <ulink
      url="http://www.hibernate.org">Hibernate</ulink> for accessing the
      database and <ulink
      url="http://logging.apache.org/log4j/docs/">Log4J</ulink> for logging.
      This tutorial omits the details of their configuration and usage.</para>
    </sect2>

    <sect2>
      <title>Introduction to writing widgets</title>

      <para>The first custom widget written for main example is
      <literal>LoginWidget</literal>. It is simple, but gives a good
      demonstration of stateful controller capabilities. Simple login screen
      is built and upon receiving successful login event, it replaces itself
      on the flowcontainer's call stack with real application widget (flow).
      After session timeout state is lost and the user is once again forced to
      log in.</para>

      <para>We build the login widget in its <literal>init()</literal>
      method.</para>

      <programlisting role="java">public class LoginWidget extends TemplateBaseWidget {
  /* Widget we will create and attach to this widget. */
  private FormWidget form;

  protected void init() throws Exception {
    /* Sets the view selector that will be used for rendering this widget. 
     * The path to real JSP file is determined by:
     *
     * StandardJspFilterService field jspPath (configured in aranea-conf.xml) 
     * + viewselector 
     * + ".jsp" */
    setViewSelector("login");

    /* Register a global proxying eventlistener - it receives all widget events and upon 
     * receiving event named "someEvent" proxies it to "handleEventSomeEvent" method 
     * 
     * This listener is added by default in super class and is only shown here for
     * illustrative purposes. It can also be cleared and overridden when needed.
     */   
     addGlobalEventListener(new ProxyEventListener(this));

    /* Create a new FormWidget with two self-described input fields. */
    form = new FormWidget();
    // Add the input fields. Arguments taken by addElement():  
    // String elementName, String labelId, Control control, Data data, boolean mandatory
    form.addElement("username", "#User", new TextControl(), new StringData(), false);
    form.addElement("password", "#Password", new TextControl(), new StringData(), false);

    // attach created form to our widget. 
    addWidget("loginForm", form);
  }

  // event handlers
}</programlisting>

      <para>Note that when creating a new form element, the
      <literal>Control</literal> that it represents and the data type it
      contains, are specified. Specifying <literal>Control</literal> is always
      necessary, <literal>Data</literal> can be left unspecified when one has
      some predefined bean associated with the form and uses
      <literal>BeanFormWidget</literal> instead of
      <literal>FormWidget</literal>.</para>

      <para>Note also the line <literal>addWidget("loginForm",
      form)</literal>. Here we add another widget (in this case the
      <literal>form</literal>) as our login widget's child, associating it
      with a particular identifier "loginForm". This will allow the child
      widget to process requests (read data submitted by user) and receive
      user events, and the identifier can be used for specifying the child
      widget, when it should be rendered.</para>

      <para>To make widget useful and interactive, we must add login event
      handlers to it.</para>

      <programlisting role="java">public void handleEventLogin() throws Exception {
  /* convertAndValidate() fails if data found from form does not 
   * satisfy the restrictions laid on it. If that is the case, 
   * we ignore received event. For loginForm we only placed one constraint -
   * username field must not be empty. */
  if (form.convertAndValidate()) {
    // find out the username supplied
    String username = (String) form.getValueByFullName("username");
    String password = (String) form.getValueByFullName("password");
    /* Add the message about wrong credentials to message context. 
     * Messages will be rendered in response (shown to user). */
    getMessageCtx().showErrorMessage("User '" + username + "'" + " not allowed to log in with password '" + password + "'");
    // do nothing - don't let anyone in :) with this event
  }
}

/* Successful login event - does not check supplied credentials, 
 * promptly replaces login widget with root widget - allowing
 * user to start work with real examples. Demonstrates simple 
 * flow navigation. */ 
public void handleEventBypass() throws Exception {
  getFlowCtx().replace(new TemplateRootWidget(), null);
}</programlisting>

      <para>Most important here is to understand the
      <literal>handleEventBypass()</literal>. Our widget (which is running as
      a <emphasis>flow</emphasis> here) replaces itself with another and is
      gone for now, until someone creates and starts it again (or session
      timeouts).</para>

      <para>Flows are a way of navigating in Aranea. A widget running as a
      flow can replace itself with another widget, but it can also start a
      nested flow by creating a new widget instance and calling
      <literal>getFlowCtx().start()</literal>. Usually we will use the words
      "widget" and "flow" interchangeably, when widget is running as a
      flow.</para>

      <para>You may think of flows as web pages that call and replace each
      other—and may return control to calling flow with
      <literal>getFlowCtx.finish()</literal>.</para>

      <para>Finally the JSP page that renders the
      <literal>LoginWidget</literal>. Do not pay much attention to
      <emphasis>&lt;div&gt;</emphasis>s and other HTML constructs - important
      tags are preceded by namespace <literal>ui</literal>—in our examples
      this namespace includes both Aranea standard and template tags (found in
      examples/common).</para>

      <programlisting role="xml">&lt;!-- This file is located in examples/main/war/WEB-INF/jsp/login.jsp --&gt;
&lt;jsp:root 
  xmlns:jsp="http://java.sun.com/JSP/Page" 
  xmlns:c="http://java.sun.com/jstl/core" 
  xmlns:ui="http://araneaframework.org/tag-library/template" version="1.2"&gt;
  &lt;jsp:directive.page contentType="text/html; charset=UTF-8"/&gt;
    
  &lt;!-- This tag should always be the root of any Aranea template JSP. 
  Its main function is to allow JSP access the controller. --&gt;
  &lt;ui:root&gt;
    &lt;!-- This tag should be immediately under the ui:root tag for any application that uses widgets. 
         It allows widgets to be rendered and included. --&gt;
    &lt;ui:viewPort&gt;
      &lt;!-- This tag should generally be the root of every widget JSP. It makes the widget view model 
      accessible as an EL variable. It can also be used to render a descendant widget in the same JSP 
      with the current widget. In the latter case you should set the id attribute to the identifier path 
      of the descendent widget in question. Note that all widget-related tags inside of this tag will 
      assume that the widget in question is their parent or ancestor (that is all the identifier pathes 
      will start from it). --&gt;
      &lt;ui:widgetContext&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
            &lt;!-- Scripts --&gt;
            &lt;jsp:include page="scripts.jsp"/&gt;
            &lt;title&gt;Aranea Template Application Login Screen&lt;/title&gt;
          &lt;/head&gt;
         
          &lt;!-- Aranea JSP specific HTML body tag, scripts won't work correctly without it. --&gt;
          &lt;ui:body&gt;
            &lt;!-- This tag will render an HTML form tag along with some Aranea-specific hidden fields. 
            It is strongly suggested to have only one system form in the template and have it submit using 
            POST. This will ensure that no matter what user does no data is ever lost. --&gt;
            &lt;ui:systemForm method="POST"&gt;

              &lt;div id="outer"&gt;
                &lt;div id="middle"&gt;
                  &lt;div id="inner"&gt;
                    &lt;div class="login"&gt;
                      &lt;div id="login-logo"&gt;
                        &lt;ui:image src="gfx/logo_aranea_login.jpg"/&gt;
                      &lt;/div&gt;

                      &lt;div class="a"&gt;
                        &lt;!-- This tag will render messages of given type if they are present in current MessageContext,
                            ie message about failured login (wrong username or password). "styleClass" attribute
                            defines the CSS style used for message display. --&gt;
                        &lt;ui:messages styleClass="msg-error"/&gt;

                        &lt;!-- This is the form we added to our LoginWidget.
                            Tag makes it the current form context tag and allows accessing 
                            form's subelements just by their names, no path is needed. --&gt;
                        &lt;ui:form id="loginForm"&gt;

                          &lt;ui:formElement id="username"&gt;
                            &lt;!-- Outputs the form element label --&gt;
                            &lt;ui:label/&gt;
                            &lt;!-- Outputs the input field for username --&gt;
                            &lt;ui:textInput styleClass="usr"/&gt;
                          &lt;/ui:formElement&gt;
                          
                          &lt;ui:formElement id="password"&gt;
                            &lt;ui:label/&gt;
                            &lt;ui:passwordInput styleClass="pwd"/&gt;
                          &lt;/ui:formElement&gt;

                          &lt;div class="clear1"&gt;&lt;ui:nbsp/&gt;&lt;/div&gt;

                          &lt;div class="actions"&gt;
                            &lt;!-- Render buttons that will submit all systemForm data, 
                                and tie them with events defined in LoginWidget. --&gt;
                            &lt;ui:eventButton eventId="login" labelId="#Login"/&gt;
                            &lt;ui:eventButton eventId="bypass" labelId="#Bypass login"/&gt;
                          &lt;/div&gt;

                          &lt;div class="clear1"&gt;&lt;ui:nbsp/&gt;&lt;/div&gt;
                        &lt;/ui:form&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
                
            &lt;/ui:systemForm&gt;
          
          &lt;/ui:body&gt;        
        &lt;/html&gt;
      &lt;/ui:widgetContext&gt;
    &lt;/ui:viewPort&gt;
  &lt;/ui:root&gt;
&lt;/jsp:root&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Creating master page and menu</title>

      <para>Our second goal after creating a login widget is a little more
      complicated—creating a menu widget and "master page" for it—root JSP
      that will be included in every page and renders application menu and
      currently active flow.</para>

      <para>What we need from the menu is basically the ability to start
      widgets (flows) on demand. As we already saw, this ability is not
      special, every widget can start other widgets. However menu should not
      become inactive, which means that it should itself run as a flow
      container, not just a flow. Using <literal>TemplateMenuWidget</literal>
      from org.araneaframework.example.common package as a base, creating menu
      widget is fairly simple:</para>

      <programlisting role="java">public class MenuWidget extends TemplateMenuWidget  {
  public MenuWidget(Widget topWidget) throws Exception {
    super(topWidget);
  }

  protected MenuItem buildMenu() throws Exception {
    // the top menu
    MenuItem result = new MenuItem();

    result.addMenuItem(null, new MenuItem("Management")); {
      result.addMenuItem("Management", new MenuItem("Persons"));
      result.addMenuItem("Management.Persons", new MenuItem("View", TemplatePersonChooseAndViewWidget.class));
      result.addMenuItem("Management.Persons", new MenuItem("Add", TemplatePersonEditWidget.class));
      
      // ...
      
      result.addMenuItem("Management", new MenuItem("Contracts"));
      result.addMenuItem("Management.Contracts", new MenuItem("View", TemplateContractChooseAndViewWidget.class));
      result.addMenuItem("Management.Contracts", new MenuItem("Add", TemplateContractEditWidget.class));
      result.addMenuItem("Management.Contracts", new MenuItem("Edit", TemplateContractChooseAndEditWidget.class));
    }
    
    // Another way of adding menuitems is available.
    MenuItem sampleMenu = result.addMenuItem(new MenuItem("Demos")); {
      sampleMenu.addMenuItem("Simple", new MenuItem("Simple_Form", SimpleFormWidget.class));
      sampleMenu.addMenuItem("Simple", new MenuItem("Simple_List", SimpleListWidget.class));
      sampleMenu.addMenuItem("Simple", new MenuItem("Search_Form", FormComplexConstraintDemoWidget.class));
    }

    return result;
  }
}</programlisting>

      <para><literal>MenuItem</literal> creation takes two
      parameters—localizable menu label <emphasis>key</emphasis> and flow
      class that should be instantiated (with no argument constructor) and
      activated when <literal>MenuItem</literal> is selected. Those classes
      must be <literal>Widgets</literal>. Instead of flow classes,
      <literal>FlowCreator</literal>s can be used to create flows that have
      more complex constructors.</para>

      <para>Created menu is added to widget view model automatically, under
      name "menu" and will be accessible from JSP as EL (<emphasis>Expression
      Language</emphasis>) variable called ${viewData.menu}.</para>

      <para>Now that we have a menu we can proceed to the root widget that
      will host it. Note that menu is just another widget and since we want it
      to run independently (not as a flow) the simplest thing to do is to add
      it as a child to the root widget. <programlisting role="java">public class RootWidget extends BaseUIWidget {
  protected void init() throws Exception {
    addWidget("menu", new MenuWidget(null));
    setViewSelector("root");
  }
}</programlisting>and render it from <literal>RootWidget</literal> JSP. Since
      menu is a flow container, including it as a widget (using tag
      &lt;ui:widgetInclude&gt;) will by default render the current active
      flow. This means that to actually render the clickable menu we will have
      to include a separate JSP. For the sake of brevity we will strip
      irrelevant parts from our example JSP snippets from now on.</para>

      <programlisting role="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 ...
  &lt;ui:systemForm method="POST"&gt;

    &lt;!-- Renders the menu on top of the screen --&gt;
    &lt;jsp:include page="/WEB-INF/jsp/mainlayout/menu.jsp"/&gt;
    &lt;div class="stripe1"&gt;&lt;ui:nbsp/&gt;&lt;/div&gt;

    &lt;div id="wholder"&gt;
      &lt;!-- Renders the side menu on left side of screen --&gt;
      &lt;jsp:include page="/WEB-INF/jsp/mainlayout/sidemenu.jsp"/&gt;

      &lt;div id="content"&gt;
        &lt;ui:messages/&gt;

        &lt;!-- Renders the menu widget itself. 
          As MenuWidget is a flow container, 
          this means that the actual widget
          rendered here is the active flow 
          (whatever widget that is on top of call
          stack at the moment of rendering). --&gt;
        &lt;ui:widgetInclude id="menu"/&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="clear1"&gt;&lt;ui:nbsp/&gt;&lt;/div&gt;

  &lt;/ui:systemForm&gt;
...</programlisting>

      <para>JSP-s that render top menu and side menu are quite similar. We
      will only present the top menu JSP here.<programlisting role="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
...
  &lt;!-- Widget identifier must be set here, because we want to render MenuWidget, 
  not RootWidget (which includes this JSP, thereby providing its own widget context) here. 
  As you remember menu widget child identifier was "menu" --&gt;
  &lt;ui:widgetContext id="menu"&gt;
    &lt;div id="header"&gt;
      &lt;div class="box1"&gt;
        &lt;a href="#" id="logo"&gt;
          &lt;ui:image src="gfx/logo_aranea_screen.jpg"/&gt;
        &lt;/a&gt;

        &lt;div id="menu1"&gt;
          &lt;!-- ${viewData.VariableName} allows us to access data 
              that was explicitly added to widget view model by the programmer
              with putViewData() method. TemplateMenuWidget adds menu
              information that way. --&gt;
          &lt;c:forEach items="${viewData.menu.subMenu}" var="item"&gt;
            &lt;div class="item"&gt;
              &lt;c:if test="${item.value.selected}"&gt;
                &lt;!-- create a button that 
                  * has a label
                  * submits event called "menuSelect"
                  * (that event is received by menu event handler defined in TemplateMenuWidget)
                  * submits label id as event parameter 
                  * CSS class is active, indicating that this menu item is selected currently --&gt;
                &lt;ui:eventLinkButton 
                  eventId="menuSelect" 
                  eventParam="${item.value.label}" 
                  labelId="${item.value.label}" 
                  styleClass="${activeStyle}"/&gt;
              &lt;/c:if&gt;

              &lt;c:if test="${not item.value.selected}"&gt;
                &lt;!-- same as the other button, but menu item is not selected --&gt;
                &lt;ui:eventLinkButton 
                  eventId="menuSelect" 
                  eventParam="${item.value.label}" 
                  labelId="${item.value.label}"/&gt;
              &lt;/c:if&gt;
            &lt;/div&gt;
          &lt;/c:forEach&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;/ui:widgetContext&gt;
...</programlisting> This completes the menu system and master page, so now we
      can concentrate on actual programming of Aranea widgets.</para>
    </sect2>

    <sect2>
      <title>Simple example widgets</title>

      <sect3>
        <title>Forms</title>

        <para>Forms allow end-user to enter data and transfer it to wherever
        application programmer chooses. Aranea represents forms by
        <literal>FormWidget</literal> and <literal>BeanFormWidget</literal>
        classes. We will look at <literal>FormWidget</literal> first, because
        using it requires a little less setup. In practice, application
        programmers will probably be using <literal>BeanFormWidget</literal>
        most of the time—because of its convenient data binding (tying model
        objects with forms) capabilities.</para>

        <sect4>
          <title>Simple Form (FormWidget)</title>

          <mediaobject id="first-form-image" xreflabel="Simple form">
            <imageobject>
              <imagedata align="center" fileref="images/first-form.png"
                         format="PNG" />
            </imageobject>

            <caption align="top">Simple form</caption>
          </mediaobject>

          <para>Our first example is the one that can be found under
          <literal>Demos-&gt;Simple-&gt;Simple Form</literal> in example
          application. It demonstrates form creation and reading single values
          from form. We also use <literal>MessageContext</literal> to
          communicate input values back to web application user.</para>

          <programlisting role="java">...
// we hold the form as instance variable
private FormWidget simpleForm;

/**
* Builds the form.
*/
protected void init() throws Exception {
  super.init();

  setViewSelector("sample/simpleForm");

  // creation of new form
  simpleForm = new FormWidget();

  // Now that we have created a form, we will need to add form elements.
  // Form elements consist of four basic things - label, Control that implements
  // form element functionality, Data holding values that form element can have.
  // Note that the first sample with FormWidget's createElement method is not the
  // way form elements are usually added to the form, but rather emphasises the
  // fact that everything you add to FormWidget is a FormElement.

  // createElement(String labelId, Control control, Data data, boolean mandatory)
  FormElement el = simpleForm.createElement("#Textbox", new TextControl(), new StringData(), false);
  simpleForm.addElement("textbox1", el);

  // and here we add form elements to form without the extra step taken previously. 
  simpleForm.addElement("checkbox1", "#Checkbox", new CheckboxControl(), new BooleanData(), false);
  simpleForm.addElement("dateTime", "#DateTime", new DateTimeControl(), new DateData(), false);
  simpleForm.addElement("time", "#Time", new TimeControl(), new DateData(), false);
  simpleForm.addElement("date", "#Date", new DateControl(), new DateData(), false);
  simpleForm.addElement("number", "#Number", new FloatControl(), new BigDecimalData(), true);
  // require the number input field to be filled. It could have been achieved already
  // on formelement creation by setting mandatory attribute to true
  simpleForm.getElement("number").setConstraint(new NotEmptyConstraint());
  // sets initial value of form element
  simpleForm.setValueByFullName("dateTime", new Date());

  // now we construct a button, that is also Control. Reason why we cannot just add it
  // to form is obvious, we want to add a specific listener to button before.
  ButtonControl button = new ButtonControl();
  button.addOnClickEventListener(new ProxyOnClickEventListener(this, "testSimpleForm") );
  // add the button to form. As the button does not hold any value, Data will be null.
  simpleForm.addElement("button", "#Button", button, null, false);

  // the usual, add the created widget to main widget.
  addWidget("simpleForm", simpleForm);
}

/**
* A test action, invoked when button is pressed. It adds the values of 
* formelements to message context, and they end up at the top of user screen
* at the end of the request.
*/
public void handleEventTestSimpleForm() throws Exception {
  // if form is not invalid, do not try to show form element values 
  // (error messages are added automatically to the messagecontext 
  // though, user will not be without feedback)
  if (simpleForm.convertAndValidate()) {
    // long way to check form element value ...
    getMessageCtx().showInfoMessage("Checkbox value is: " + ((FormElement) simpleForm.getElement("checkbox1")).getData().getValue());
    // and a shorter one
    getMessageCtx().showInfoMessage("Textbox value is: " + simpleForm.getValueByFullName("textbox1"));
    getMessageCtx().showInfoMessage("DateTime value is: " + simpleForm.getValueByFullName("dateTime"));
    getMessageCtx().showInfoMessage("Time value is: " + simpleForm.getValueByFullName("time"));
    getMessageCtx().showInfoMessage("Date value is: " + simpleForm.getValueByFullName("date"));
    getMessageCtx().showInfoMessage("Number value is: " + simpleForm.getValueByFullName("number"));
  }
}

...</programlisting>

          <para>JSP used to render the previous widget is presented below and
          should be quite self explaining with the given commentary. Pay
          attention to tags used to render FormElements with corresponding
          controls—<literal>DateControl</literal> and
          <literal>&lt;ui:dateInput&gt;</literal>,
          <literal>TextControl</literal> and
          <literal>&lt;ui:textInput&gt;</literal> etc. Aranea standard tag
          library typically contains more than one way for rendering any given
          <literal>Control</literal>—most <literal>Controls</literal> have
          tags for both input and display rendering (e.g
          <literal>&lt;ui:textInput&gt;</literal>,
          <literal>&lt;ui:textDisplay&gt;</literal>). If the need arises, you
          can write your own tags to customize rendering of standard (or
          custom) controls.</para>

          <programlisting role="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- Set the form context, the form we will be rendering here. 
    We cannot as simply (using non-qualified names) refer to form 
    elements unless we define the form context here. --&gt;
&lt;ui:form id="simpleForm"&gt;

  &lt;!-- Now, these are the first custom tags in template application. They do
       nothing particularly interesting, just set up the HTML DIV element
       containing the component header --&gt;
  &lt;ui:componentHeader&gt;
    &lt;ui:componentName&gt;Tutorial first form&lt;/ui:componentName&gt;
  &lt;/ui:componentHeader&gt;

  &lt;!-- Another custom template tag, purely design-focused (look ComponentTag for source)--&gt;
  &lt;ui:component&gt;

    &lt;!-- Custom tag, but more interesting that previous tags. It derives from
         LayoutHtmlTag tag and allows putting row tags inside of it. 
         Attribute rowClasses defines the styleClass attribute for rows inserted under 
         componentForm here, cellClasses does the same for cells. These classes are repeating
         e.g first cell in a row is with styleClass "name", second with "inpt", and third
         cell again has styleClass "name". In HTML, this tag creates a TABLE. --&gt;
    &lt;ui:componentForm rowClasses="cols4" cellClasses="name, inpt"&gt;

      &lt;!-- As we can insert rows now, we do just that. --&gt;
      &lt;ui:row&gt;
        &lt;!-- ... we can insert cells too! As we defined componentForm rowClass 
            to be cols4  we should insert 4 cells here... --&gt;
        &lt;ui:cell&gt;
          &lt;!-- label is formelement centric tag. As we are inside the form 
          already, we provide it with form element id and corresponding 
          form element label will be shown --&gt;
          &lt;ui:label id="checkbox1" /&gt;
        &lt;/ui:cell&gt;

        &lt;ui:cell&gt;
          &lt;!-- This is another approach to providing information about
              form element that tag should apply to - instead providing
              form element id to every single tag, tags could be enclosed
              inside single formElement tag.
           --&gt;
          &lt;ui:formElement id="checkbox1"&gt;
            &lt;!-- will draw a checkbox tied to form element with id "checkbox1" --&gt;
            &lt;ui:checkbox/&gt;
          &lt;/ui:formElement&gt;
        &lt;/ui:cell&gt;

        &lt;ui:cell&gt;
          &lt;ui:label id="textbox1" /&gt;
        &lt;/ui:cell&gt;

        &lt;ui:cell&gt;
          &lt;!-- As "textbox1" is TextControl, we choose the corresponding tag to render it --&gt;
          &lt;ui:textInput id="textbox1" /&gt;
        &lt;/ui:cell&gt;
      &lt;/ui:row&gt;

      &lt;!-- another row, and we just keep on going until all form elements have been described. --&gt;
      &lt;ui:row&gt;
        &lt;ui:formElement id="dateTime"&gt;
          &lt;ui:cell&gt;
            &lt;!-- "dateTime" label --&gt;
            &lt;ui:label /&gt;
          &lt;/ui:cell&gt;

          &lt;ui:cell&gt;
            &lt;!-- "dateTime" input field --&gt;
            &lt;ui:dateTimeInput/&gt;
          &lt;/ui:cell&gt;
        &lt;/ui:formElement&gt;

        &lt;ui:formElement id="time"&gt;
          &lt;ui:cell styleClass="name"&gt;
            &lt;ui:label /&gt;
          &lt;/ui:cell&gt;

          &lt;ui:cell&gt;
            &lt;ui:timeInput /&gt;
          &lt;/ui:cell&gt;
        &lt;/ui:formElement&gt;
      &lt;/ui:row&gt;

      &lt;ui:row&gt;
        &lt;ui:formElement id="date"&gt;
          &lt;ui:cell styleClass="name"&gt;
            &lt;ui:label /&gt;
          &lt;/ui:cell&gt;

          &lt;ui:cell&gt;
            &lt;ui:dateInput /&gt;
          &lt;/ui:cell&gt;
        &lt;/ui:formElement&gt;
      &lt;/ui:row&gt;

    &lt;/ui:componentForm&gt;

    &lt;!-- pure design tag --&gt;
    &lt;ui:componentActions&gt;
      &lt;ui:formElement id="button"&gt;
        &lt;ui:button/&gt;
      &lt;/ui:formElement&gt;
    &lt;/ui:componentActions&gt;
  &lt;/ui:component&gt;

&lt;/ui:form&gt;
</programlisting>
        </sect4>

        <sect4>
          <title>Simple BeanFormWidget</title>

          <mediaobject id="bean-form-image" xreflabel="Simple beanform">
            <imageobject>
              <imagedata align="center" fileref="images/simple-beanform.png"
                         format="PNG" />
            </imageobject>

            <caption align="top">Simple form associated with
            JavaBean.</caption>
          </mediaobject>

          <para>Next example is
          <literal>org.araneaframework.example.main.web.person.PersonAddEditWidget</literal>
          that demonstrates <literal>BeanFormWidget</literal> usage—binding a
          data model (JavaBean with getter and setter methods for instance
          fields) to a form. Data model being bind to form is of the
          <literal>PersonMO</literal> class. In actual source code,
          <literal>PersonMO</literal> class also contains
          <literal>xdoclet</literal> annotations telling Hibernate database
          tables and columns where JavaBean data should be saved, these are
          removed from tutorial sample code as they tell nothing useful about
          Aranea.</para>

          <programlisting role="java">public class PersonMO implements GeneralMO {
  private Long id;
  private String name;
  private String surname;
  private String phone;
  private Timestamp birthdate;

  public Long getId() {
    return id;
  }
  public void setId(Long id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }

  // and all other getters and setters for instance fields
  ...

}</programlisting>

          <para>When you have model ready, using
          <literal>BeanFormWidget</literal> is almost the same as using
          <literal>FormWidget</literal>. Main bonus is that specifing
          <literal>Data</literal> when adding <literal>FormElements</literal>
          to form is no longer needed as it is determined from model class.
          Also <literal>BeanFormWidget's</literal>
          <literal>readBean()</literal> and <literal>writeBean(Object
          beanClass)</literal> methods allow programmer to read and write all
          form fields conveniently.</para>

          <programlisting role="java">public class PersonAddEditWidget extends TemplateBaseWidget {
  /* The ID field of the person data model, only has value if object has already
     been saved to/loaded from database. */
  private Long personId;
  // Whether the person is being edited or added
  private boolean editMode;
  
  /* The form. Person data (represented by class PersonMO) will be binded to it, thus 
     usage of BeanFormWidget instead of FormWidget. */
  private BeanFormWidget form;

  /**
   * Constructor for adding new person.
   */
  public PersonAddEditWidget() {
  }

  /**
   * Constructor for editing existing person with specified Id.
   * @param personId Person's Id.
   */
  public PersonAddEditWidget(Long id) {
    this.personId = id;
    editMode = true;
  }
  
  protected void init() throws Exception {
    super.init();

    // Sets the view selector that will be used for rendering this widget. */ 
    setViewSelector("person/personAddEdit");
    // This viewdata is used in JSP to set component header (different for editing and adding). 
    putViewData("label", editMode ? "person.edit.form.label" : "person.add.form.label");

    /* Register a global proxying eventlistener - it receives all widget events and upon 
     * receiving event named "someEvent" proxies it to "handleEventSomeEvent" method. */
    addGlobalEventListener(new ProxyEventListener(this));

    form = buildPersonEditForm();
    addWidget("personForm", form);
  }

  private BeanFormWidget buildPersonEditForm() throws Exception {
    /* Create the form, specifying the class of data that is binded to this form. */
    BeanFormWidget form = new BeanFormWidget(PersonMO.class);
    
    /* Adding the elements is done like in our SimpleFormWidget example, except
     * that Data type is determined from bean class automatically and specifying
     * it is not needed. */
    
    // BeanFormWidget.addBeanElement(String elementName, String labelId, Control control, boolean mandatory)
    form.addBeanElement("name", "#First name", new TextControl(), true);
    form.addBeanElement("surname", "#Last name", new TextControl(), false);
    form.addBeanElement("phone", "#Phone no", new TextControl(), true);
    form.addBeanElement("birthdate", "#Birthdate", new DateControl(), false);
    form.addBeanElement("salary", "#Salary", new FloatControl(), false);
    
    if (editMode) {
      /* fetch the person with given ID from database */
      PersonMO person = (PersonMO) getGeneralDAO().getById(PersonMO.class, personId);
      /* and fill the form with current person data */
      form.writeBean(person);
    } /* otherwise we have no data and all form fields are initially left blank */

    return form;
  }
  
  public void handleEventSave(String eventParameter) throws Exception {
    // if form data is found to be valid  
    if (form.convertAndValidate()) {
      // get the current person data (retrieved from database by getGeneralDAO() in case person already has assigned ID); 
      PersonMO person = personId != null ? (PersonMO) getGeneralDAO().getById(PersonMO.class, personId) : new PersonMO();
      // read the application user supplied data from form into model object.
      person = (PersonMO) form.readBean(person);
      
      if (editMode) {
        // updates person object in database
        getGeneralDAO().edit(person);
      } else {
        // saves new person object to database
        personId = getGeneralDAO().add(person);                 
      }

      /* finish current flow execution and return to calling flow, returning database ID 
       * of added or edited person */ 
      getFlowCtx().finish(personId);
    } else {
      /* Do nothing, error messages are applied to MessageContext by validating methods 
       * so that application user receives immediate feedback about incorrectly filled
       * form elements automatically. */
    }
  }
}</programlisting>

          <para>JSP for <literal>PersonAddEditWidget</literal> is very similar
          to previous form rendering JSP examples and we will not include it
          here. It can be found from
          <literal>examples/main/war/WEB-INF/jsp/person/personAddEdit.jsp</literal></para>

          <para>Both <literal>FormWidgets</literal> and
          <literal>BeanFormWidgets</literal> may also contain subforms, these
          can be added with <literal>addSubForm()</literal> and
          <literal>addBeanSubForm()</literal> methods. Also, the model object
          non-primitive JavaBean fields are accessible, e.g given model
          classes</para>

          <programlisting role="java">...
public static class NameMO implements GeneralMO {
  private String firstname;
  private String surname;
  
  public Long getFirstname() {
    return id;
  }
  public void setFirstname(String name) {
    this.firstname = name;
  }

  public String setSurname(String name) {
    this.surname = name;
  }

  public String getSurname() {
    return name;
  }
}
               
public static class PersonMO implements GeneralMO {
  private Long id;
  private NameMO name;
  private String phone;
  private Timestamp birthdate;

  public Long getId() {
    return id;
  }
  public void setId(Long id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(NameMO name) {
    this.name = name;
  }

  // and all other getters and setters for instance fields
  ...
}

...
</programlisting>

          <para>the model class fields can be referred to as</para>

          <programlisting role="java">...
BeanFormWidget form = new BeanFormWidget(PersonMO.class);
form.addBeanElement("name.firstname", "#First name", new TextControl(), true);
form.addBeanElement("name.surname", "#Surname", new TextControl(), true);
...</programlisting>

          <para>when constructing the
          <literal>BeanFormWidget</literal>.</para>
        </sect4>

        <sect4>
          <title>Advanced forms</title>

          <mediaobject id="complex-form-image" xreflabel="Complex form">
            <imageobject>
              <imagedata align="center" fileref="images/complex-form.png"
                         format="PNG" />
            </imageobject>

            <caption align="top">Complex form</caption>
          </mediaobject>

          <para>Real world forms tend to be considerably more complex than
          simple examples presented before. They very often need to
          dynamically change—based on user input(s) form functionality and
          content need to be altered. What one usually does for creating such
          dynamic forms is registering event listeners on controls and upon
          receiving event(s) updates forms dynamically. This can be
          accomplished with pure HTTP requests or AJAX (XMLHttpRequest or
          Msxml2.XMLHTTP) requests. AJAX requests have gained much popularity
          lately because they allow running complex business logic on
          background and updating HTML pages without full HTTP request (on
          older computers over slower connections this is sure way to cause
          uncomfortable flicker).</para>

          <para>Next class we will be presenting is
          <literal>DemoComplexForm</literal> from our main example
          (<emphasis>Demos-&gt;Advanced-&gt;Ajaxian Form</emphasis>). It is
          not "complex" in the sense that it would be hard to understand, but
          it demonstrates concepts that can be used for creation of very
          sophisticated forms. The form contains a
          <literal>SelectControl</literal>, depending on value selected from
          it, different subwidgets are shown (subwidget updates are performed
          with AJAX requests).</para>

          <programlisting role="java">public class DemoComplexForm extends TemplateBaseWidget {
  /* Different controls and widgets we want to be accessible all the time are 
     made instance variables by convention. */
  private FormWidget complexForm;
  /* SelectControl - control which provides various selections from which one must be picked. */
  private SelectControl beastSelectionControl;
  /* MultiSelectControl - provides various selections from which zero to many can be picked */
  private MultiSelectControl concreteBeastMultiSelectionControl;

  protected void init() throws Exception {
    super.init();

    setViewSelector("demo/demoComplexForm");
    putViewData("formLabel", "Complex_Form");
    
    beastSelectionControl = new SelectControl();
    /* SelectControls can be added DisplayItems, one by one ... */
    beastSelectionControl.addItem(new DisplayItem(null, "-choose-"));
    /* or whole collections of value objects, which must have getters for specified value
     * and displayString fields (here, for sampleValue and sampleDisplayString). Note that 
     * both value and displayString must be of String class */
    beastSelectionControl.addDisplayItems(getSelectItems(), "sampleValue", "sampleDisplayString");

    /* Adds the onChange event listener to selectControl */
    beastSelectionControl.addOnChangeEventListener(new OnChangeEventListener() {
      public void onChange() throws Exception {
        /* Form must be converted before new values can be read from form.
           As we want to be sure that entered data is valid (no random strings
           where numbers are expected, length and content constraints are met)
           we usually also validate data before using it for anything. */
        if (complexForm.convertAndValidate()) {
          // get the value from control
          String selectedBeast = (String)beastSelectionControl.getRawValue();

          // if no beast is selected in our select control, we remove the other 
          // elements from form that depend directly on selection being made - 
          // the controls providing possibily for more specific beast selection.
          if (selectedBeast == null) {
            complexForm.removeElement("concreteBeastControl");
            complexForm.removeElement("selectedBeastDesc");
            return;
          }

          // create the multiselectcontrol allowing selection of some beasts of selected type.
          concreteBeastMultiSelectionControl = new MultiSelectControl();
          for (Iterator i = getMultiSelectItems(selectedBeast).iterator(); i.hasNext(); ) {
            String current = (String) i.next();
            concreteBeastMultiSelectionControl.addItem(new DisplayItem(current, current));
          }
          
          // finally add both beast group description and beast selection control to this widget.  
          complexForm.addElement("concreteBeastControl","#Choose " + selectedBeast, 
                                  concreteBeastMultiSelectionControl, new StringListData(), false);
          complexForm.addElement("selectedBeastDesc", "#Description", new DisplayControl(), new StringData(), false);
          // if not dealing with beanforms, form element values are typically set this way
          complexForm.setValueByFullName("selectedBeastDesc", new SelectItem(selectedBeast).getDescription());
        }
      }
    });
    
    complexForm = new FormWidget();
    complexForm.addElement("beastSelection", "#Nature's Beasts", beastSelectionControl, new StringData(), true);
    
    addWidget("complexForm", complexForm);
  }

}</programlisting>

          <para>JSP view for this file is only a little fancier than previous
          ones:</para>

          <programlisting role="xml">&lt;ui:widgetContext&gt;
  &lt;ui:form id="complexForm"&gt;

    &lt;ui:componentHeader&gt;
      &lt;ui:componentName&gt;
        &lt;!-- The label, defined in DemoComplexForm class. --&gt;
        &lt;fmt:message key="${viewData.formLabel}"/&gt;
      &lt;/ui:componentName&gt;
    &lt;/ui:componentHeader&gt;

    &lt;ui:component&gt;

      &lt;ui:componentForm&gt;

        &lt;ui:row&gt;
          &lt;ui:formElement id="beastSelection"&gt;
            &lt;ui:cell width="25%"/&gt;
            &lt;ui:cell styleClass="name"&gt;
              &lt;ui:label /&gt;
            &lt;/ui:cell&gt;
            &lt;ui:cell&gt;
              &lt;!-- Note the updateRegions attribute - it specifies the regions
                   that should be updated when event occurs (specifying this 
                   attribute also means that upon listener activation AJAX
                   request is made instead of ordinary HTTP request. globalUpdateRegions
                   refers to message regions defined in some other widgets, "messages"
                   being standard name for region where MessageContext messages are shown. 
                   Actually AJAX filter is configured to a update message region on each 
                   request anyway, this attribute is set here for illustrative purpose. --&gt;
              &lt;ui:select updateRegions="ajaxBeasts" globalUpdateRegions="messages"/&gt;
            &lt;/ui:cell&gt;
            &lt;ui:cell width="25%"/&gt;
          &lt;/ui:formElement&gt;
        &lt;/ui:row&gt;
            
        &lt;!-- Here we define the update region. All tags inside the update region
            when AJAX request which update regions include "ajaxBeasts" is made. --&gt;
        &lt;ui:updateRegionRows id="ajaxBeasts"&gt;
          &lt;!-- A way to test whether form elements are present. As both selectedBeastDesc 
              and concreteBeastControl are only added to the form if beast is selected,
              this needs to be done here. --&gt;
          &lt;c:if test="${not empty form.elements['concreteBeastControl']}"&gt;
            &lt;ui:row&gt;
              &lt;ui:formElement id="selectedBeastDesc"&gt;
                &lt;ui:cell colSpan="2" styleClass="wrap-centered" width="50%"&gt;
                  &lt;ui:textDisplay/&gt;
                &lt;/ui:cell&gt;
              &lt;/ui:formElement&gt;

              &lt;ui:formElement id="concreteBeastControl"&gt;
                &lt;ui:cell styleClass="centered-name"&gt;
                  &lt;ui:label /&gt;
                &lt;/ui:cell&gt;
                &lt;ui:cell&gt;
                  &lt;!-- Render MultiSelectControl with checkboxes. 
                       Instead ui:multiSelect could be used ... --&gt;
                  &lt;ui:checkboxMultiSelect type="vertical" /&gt;
                &lt;/ui:cell&gt;
              &lt;/ui:formElement&gt;
            &lt;/ui:row&gt;
          &lt;/c:if&gt;
        &lt;/ui:updateRegionRows&gt;

      &lt;/ui:componentForm&gt;

    &lt;/ui:component&gt;

  &lt;/ui:form&gt;

&lt;/ui:widgetContext&gt;
</programlisting>

          <para>There are some things to note here—if
          <literal>&lt;ui:select&gt;</literal> attributes referring to its
          updateregions are removed (and
          <literal>&lt;ui:updateRegionRows&gt;</literal> tags also) this
          example functions just like before, only smoothness of page update
          is lost. Secondly, <literal>&lt;ui:updateRegionRows&gt;</literal>
          must be placed outside of <literal>&lt;c:if&gt;</literal> tag —it
          writes out some HTML tags that identify the region where updates
          take place and when these tags are not found, response cannot be
          rendered.</para>

          <para>Finally, expression <literal>&lt;c:if test="${not empty
          form.elements['concreteBeastControl']}"&gt;</literal> is not as
          obscure as it may seem at first. "form" refers to the current form
          ("complexForm") <emphasis>ViewModel</emphasis> that is accessible
          from JSP— its exact class being
          <literal>FormWidget.ViewModel</literal> which has
          <literal>getElements()</literal> method that returns
          <literal>java.util.Map</literal>. Square brackets
          (<literal>['concreteBeastControl']</literal>) containing element
          name are just the EL (Expression Language) way of accessing map
          elements. All widgets make their <emphasis>ViewModels</emphasis>
          accessible from JSP-s under different names, these can be used for
          building effective conditional branchings and alike. Names under
          which <literal>ViewModels</literal> and other interesting JSP
          variables can be accessed are documented in reference manual JSP
          sections.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>Lists</title>

        <mediaobject id="company-list-image" xreflabel="company list">
          <imageobject>
            <imagedata align="center" fileref="images/companyList.png"
                       format="PNG" />
          </imageobject>

          <caption align="top">BeanListWidget example, list of
          companies.</caption>
        </mediaobject>

        <para>Lists are tables containing rows with records gathered from some
        data source. They provide support for paged displays of long lists and
        filtering shown records based on their field values. Basic usage is
        quite simple:</para>

        <programlisting role="java">protected void initList() throws Exception {
  // Create the new list widget whose records are JavaBeans, instances of CompanyMO.
  // CompanyMO has fields named id, name and address.
  list = new BeanListWidget(CompanyMO.class);
  addWidget("companyList", this.list);
  // set the data provider for the list
  list.setDataProvider(new TemplateCompanyListDataProvider());
  // add the displayed columns to list.
  // addField(String id, String label, boolean orderable)
  // note that # before the label means that label is treated as unlocalized and outputted as-is
  list.addField("id", "#Id", false);
  // addField(...) returns FieldFilterHelper, like() sets LIKE filter on the column
  list.addField("name", "#Name", true).like();
  list.addField("address", "#Address", true).like();
  list.addField("dummy", null, false);
}</programlisting>

        <para>Our example uses <literal>BeanListWidget</literal> instead of
        <literal>ListWidget</literal>. Differences between the two are the
        same as between <literal>BeanFormWidget</literal> and
        <literal>FormWidget</literal>. All that is needed to create a list is
        adding showed columns to list, supplying each column with
        <emphasis>id</emphasis> that is also the name of JavaBean
        field.</para>

        <para>Additionally, one can specify whether ordering and filtering by
        given column should be available. <literal>FieldFilterHelper</literal>
        allows specifying different filters that define how the filter
        conditions specified should be applied—<literal>like()</literal>,
        <literal>eq()</literal>, <literal>lt()</literal>,
        <literal>lt()</literal>, <literal>isNull()</literal>,
        <literal>notNull()</literal>, <literal>range()</literal>. Their
        behaviour is natural, filter application shows only those records that
        satisfy the filter expression.</para>

        <para>For filling the list with data, some
        <literal>ListDataProvider</literal> must be passed to a newly created
        list. Aranea has two base classes that implement
        <literal>ListDataProvider</literal>
        interface—<literal>MemoryBasedListDataProvider</literal> and
        <literal>BackendListDataProvider</literal>. When using memory based
        data provider, all records belonging to a list are read into memory at
        once and paging and filtering takes also place completely in memory,
        whereas backend (database) based providers perform a query retrieving
        only the records that need to be shown currently (based on paging and
        filtering conditions). For long lists of complex objects, using
        <literal>BackendListDataProvider</literal> is a must—otherwise
        application will quickly start using too much memory. Data provider
        for previous list could be like this:</para>

        <programlisting role="java">private class TemplateCompanyListDataProvider extends MemoryBasedListDataProvider {
  // Overloading constructor with correct bean type.                
  protected TemplateCompanyListDataProvider() {
     super(CompanyMO.class);
  }
  // Overloading the real data loading method. Should
  // return java.util.List containing CompanyMO objects.
  public List loadData() throws Exception {
    // Here, database query is performed and all rows from COMPANY table retrieved.
    // But you could also get the data from parsing some XML file, /dev/random etc.
    // All that matters is that returned List really contains CompanyMO objects.
    return getGeneralDAO().getAll(CompanyMO.class);
  }      
}</programlisting>

        <para>or, when using
        <literal>BackendListDataProvider</literal>.</para>

        <programlisting role="java">private class BackendCompanyListDataProvider extends BackendListDataProvider {
  protected BackendCompanyListDataProvider() {
    // Constructor with argument useCache set to false.
    super(false);
  }

  // Functions as MemoryBasedListDataProvider's loadData, but takes query as an argument
  // and returns ListItemsData instead of List. ListItemsData is just a wrapper around
  // a List that contains an additional field, Long with total count of objects in list.
  protected ListItemsData getItemRange(ListQuery query) throws Exception {
    // call some method that takes a ListQuery as parameter, and returns the
    // data filtered as needed.
  }
}</programlisting>

        <para>Actual implementations of methods that return data for memory
        based or backend based lists falls outside the scope of this tutorial,
        but fine examples can be found from reference manual chapter "Lists"
        and examples source code.</para>

        <para>JSP fragment that renders the list would look something like
        that:</para>

        <programlisting role="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
...
&lt;ui:list id="companyList"&gt;
  &lt;!-- List body, where all list objects that fit on a current page will be rendered. --&gt;
  &lt;ui:listRows&gt;
    &lt;!-- Creating a row inside the listRows signals that list object will be rendered inside it. 
         ui:listRows is iterating tag, it will render as many rows as there are object to show.
         Current list object being operated on is accessible as EL variable ${row}. List objects
         field values that have getters are accessible as ${row.field}.
    --&gt;
    &lt;ui:row&gt;
      &lt;ui:cell&gt;
        &lt;!-- Accessing the row object, as described previously. --&gt;
        &lt;c:out value="${row.id}"/&gt;
      &lt;/ui:cell&gt;

      &lt;ui:cell&gt;
        &lt;ui:listRowLinkButton eventId="select"&gt;
          &lt;c:out value="${row.name}"/&gt;
        &lt;/ui:listRowLinkButton&gt;
      &lt;/ui:cell&gt;

      &lt;ui:cell&gt;
        &lt;c:out value="${row.address}"/&gt;
      &lt;/ui:cell&gt;
        
      &lt;ui:cell&gt;
        &lt;!-- Edit company button. Note the listRow prefix for the tag, it separates 
             this from ordinary linkButton tag and ensures that row's list id is
             submitted with the request. --&gt;
        &lt;ui:listRowLinkButton eventId="edit"&gt;
            &lt;ui:image code="buttonChange" alt="Edit company" title="Edit company"/&gt;
        &lt;/ui:listRowLinkButton&gt;
        &lt;!-- Remove company button. --&gt;
        &lt;ui:listRowLinkButton eventId="remove"&gt;
            &lt;ui:image code="buttonDelete" alt="Remove company" title="Remove company"/&gt;
        &lt;/ui:listRowLinkButton&gt;
      &lt;/ui:cell&gt;
        
    &lt;/ui:row&gt;
  &lt;/ui:listRows&gt;              
&lt;/ui:list&gt;
...</programlisting>
      </sect3>

      <sect3>
        <title>Editable Lists</title>

        <mediaobject id="person-editable-list-image"
                     xreflabel="personEditableList">
          <imageobject>
            <imagedata align="center" fileref="images/person-editableList.png"
                       format="PNG" />
          </imageobject>

          <caption align="top">Editable list example.</caption>
        </mediaobject>

        <para>Editable lists are <emphasis>lists of forms</emphasis>—their
        rows (and thus objects represented by these rows) can be edited,
        updated, deleted and added on-the-fly. Presented example is extracted
        from template application <literal>PersonEditableListWidget</literal>
        class. Its <literal>init()</literal> method resembles those that we
        have already seen, except few curiosities that are pointed out in code
        comments.</para>

        <programlisting role="java">public class PersonEditableListWidget extends TemplateBaseWidget {
  protected static final Logger log = Logger.getLogger(PersonEditableListWidget.class);
  
  /* Editable list. */
  private EditableBeanListWidget list;
  /* Actual holder of editable list rows (resides inside EditableBeanListWidget).
     Look inside init() method to see where it comes from. */ 
  private BeanFormListWidget formList;
  private MemoryBasedListDataProvider dataProvider = new DataProvider();
  
  protected void init() throws Exception {
    super.init();
	
    setViewSelector("person/editableList");
	
    /* PersonMO class is already familiar from form examples. */
    list = new EditableBeanListWidget(PersonMO.class);
    /* Now, this is new. Set FormRowHandler class that will handle the different row operations. */
    list.setFormRowHandler(buildFormRowHandler());
    addWidget("list", list);
    list.setOrderableByDefault(true);
    list.addField("id", "#Id", false);
    /* Filtering by fields other than ID is enabled. */
    list.addField("name", "#First name").like();
    list.addField("surname", "#Last name").like();
    list.addField("phone", "#Phone no").like();        
    list.addField("birthdate", "#Birthdate").range();
    list.addField("salary", "#Salary").range();
    list.addField("dummy", null, false);
    
    /* Set the provider through which list acquires its data. Exactly the same as for ordinary lists. */
    list.setDataProvider(buildListDataProvider());

    /* Get the convenient reference to BeanFormListWidget hiding inside EditableBeanListWidget. */
    this.formList = list.getFormList();
  }

  /* Data provider for person list. Loads all person objects from database. */
  private class DataProvider extends MemoryBasedListDataProvider {
    protected DataProvider() {
      super(PersonMO.class);
    }
    public List loadData() throws Exception {       
      return getGeneralDAO().getAll(PersonMO.class);
    }
  }

  protected ListDataProvider buildListDataProvider() throws Exception {
    return dataProvider;
  }

  protected FormRowHandler buildFormRowHandler() throws Exception {
    /* Implementation of FormRowHandler that also calls dataprovider's
     * data refresh methods when list editing events occur. */
    return new PersonEditableRowHandler());
  }

  /* Row handling functions. As this handler extends ValidOnlyIndividualFormRowHandler class,
   * its saveRow method does nothing: instead saveValidRow method should be implemented that
   * saves only these forms (rows) which data passes validation.  
   */ 
  public class PersonEditableRowHandler extends ValidOnlyIndividualFormRowHandler {
    /* Implementation of the method that must return unique key for each row
     * in editable list. As we hold database objects (PersonMO-s) in this list, 
     * it is natural to use synthetic ID field for a key.*/ 
    public Object getRowKey(Object rowData) {
      return ((PersonMO) rowData).getId();
    }
    
    // Implementation of method that should save EDITED rows which data passes validation.
    public void saveValidRow(FormRow editableRow) throws Exception {
      /* Reads data from form. FormRow.getForm() method returns the widget that is 
       * currently holding row object data -- it is either FormWidget or BeanFormWidget, as
       * in our case we are using EditableBeanListWidget that holds row data in BeanFormWidgets,
       * we can cast the return type accordingly. */
      PersonMO rowData = (PersonMO) ((BeanFormWidget)editableRow.getForm()).readBean(new PersonMO());
      rowData.setId((Long) editableRow.getKey());
      
      // Save modified object.
      getGeneralDAO().edit(rowData);
      
      // Set the row closed (for further editing, it must be opened again). 
      editableRow.close();
    }
    
    public void deleteRow(Object key) throws Exception {
      Long id = (Long) key;
      getGeneralDAO().remove(PersonMO.class, id);
    }
    
    // Implementation of method that should save ADDED rows which data passes validation.
    public void addValidRow(FormWidget addForm) throws Exception {
      PersonMO rowData = (PersonMO) (((BeanFormWidget)addForm).readBean(new PersonMO()));
      getGeneralDAO().add(rowData);
      // this callback must be made here!
      formList.resetAddForm();
    }
    
    // Called to initialize each row in editable list.
    public void initFormRow(FormRow editableRow, Object rowData) throws Exception {
      // Set initial status of list rows to closed - they cannot be edited before opened.
      editableRow.close();
      
      // Get the rowForm (this is the formwidget holding row object data). 
      BeanFormWidget rowForm = (BeanFormWidget)editableRow.getForm();
      // See below.
      addCommonFormFields(rowForm);
      /* A button that opens row for editing upon receiving onClick event.
       * Activating button in already opened row saves the row data. */
      FormListUtil.addEditSaveButtonToRowForm("#", formList, rowForm, getRowKey(rowData));
      /* A button that deletes this row and its data (calls deleteRow()). */
      FormListUtil.addDeleteButtonToRowForm("#", formList, rowForm, getRowKey(rowData));

      rowForm.writeBean(rowData);
    }
    
    // Called to initialize a blank row meant for adding new records.
    public void initAddForm(FormWidget addForm) throws Exception {
      addCommonFormFields((BeanFormWidget)addForm);
      // Button that saves the content of the new record (calls addValidRow()). 
      FormListUtil.addAddButtonToAddForm("#", formList, addForm);
    }
    
    // Adds PersonMO bean fields to given BeanFormWidget.
    private void addCommonFormFields(BeanFormWidget form) throws Exception {
      form.addBeanElement("name", "#First name", new TextControl(), true);
      form.addBeanElement("surname", "#Last name", new TextControl(),  true);
      form.addBeanElement("phone", "#Phone no", new TextControl(), false);
      form.addBeanElement("birthdate", "#Birthdate", new DateControl(), false);
      form.addBeanElement("salary", "#Salary", new FloatControl(), false);
    }
  }
}</programlisting>

        <para>As seen, defining editable lists does not differ much from
        defining ordinary lists—setting the <literal>FormRowHandler</literal>
        is the only new procedure. <literal>RowHandlers</literal> themselves
        are not complex but some callback method purposes can be confusing—
        one must be well-acquainted with row-handling interfaces before
        implementing them.</para>

        <table align="center" frame="all">
          <title><literal>FormRowHandler</literal> interface</title>

          <tgroup cols="2">
            <colspec colwidth="2*" />

            <colspec colwidth="5*" />

            <thead>
              <row>
                <entry>Method</entry>

                <entry>Purpose</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>
                  <literal>getRowKey(Object row)</literal>
                </entry>

                <entry>Should return the key that uniquely identifies given
                object among other same type objects.</entry>
              </row>

              <row>
                <entry>
                  <literal>initFormRow(FormRow formRow, Object row)</literal>
                </entry>

                <entry>Should initialize the editable row by building the form
                inside the <literal>formRow</literal> and setting the correct
                open/close status. Called once for each
                object(<literal>row</literal>) that should be showed in the
                list.</entry>
              </row>

              <row>
                <entry>
                  <literal>initAddForm(FormWidget addForm)</literal>
                </entry>

                <entry>Should initialize the form that will be used to add new
                rows. Usually modifies the supplied form as calling
                <literal>initFormRow</literal> with empty
                <literal>row</literal> parameter would alter form inside
                <literal>formRow</literal>—but here the object's unique
                identifier is not required.</entry>
              </row>

              <row>
                <entry>
                  <literal>addRow(FormWidget addForm)</literal>
                </entry>

                <entry>Called when a new row (object) should be added. Data of
                the new object should be read from the supplied form.</entry>
              </row>

              <row>
                <entry>
                  <literal>saveRows(Map &lt;Object rowKey, EditableRow
                  formRow&gt; formRows)</literal>
                </entry>

                <entry>Called when specified list rows should be
                saved.</entry>
              </row>

              <row>
                <entry>
                  <literal>deleteRows(Set rowKeys)</literal>
                </entry>

                <entry>Called when the rows (objects) identified by the
                supplied set of keys should be deleted.</entry>
              </row>

              <row>
                <entry>
                  <literal>openOrCloseRow(FormRow formRow)</literal>
                </entry>

                <entry>Called upon closing or opening of the formRow.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>JSP for editable list does not need as much work as writing
        custom rowhandlers. instead of <literal>&lt;ui:list&gt;</literal> tag
        <literal>&lt;ui:formList&gt;</literal> should be used (in our example
        both are used). <literal>&lt;ui:listRows&gt;</literal> is replaced by
        <literal>&lt;ui:formListRows&gt;</literal> and object adding form is
        rendered inside <literal>&lt;ui:formListAddForm&gt;</literal>.</para>

        <programlisting role="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
... 
&lt;!-- See examples/main/war/WEB-INF/jsp/person/editableList.jsp for complete file. --&gt;
&lt;!-- Start the list context ... --&gt;
&lt;ui:list id="list"&gt;
  &lt;!-- and continue with announcement that this list is editable, although --&gt;
  &lt;!-- just ui:formList id="list" would have been sufficient. --&gt;
  &lt;ui:formList&gt;
  ...
    &lt;!-- List filter for editable list is exactly 
         the same as filter for ordinary lists --&gt;
    &lt;ui:listFilter&gt;
      &lt;!-- rows --&gt;
      ...
    &lt;/ui:listFilter&gt;
    
    &lt;!-- Editable list rows. This tag usage is similar to ui:listRows;
         but it makes available some extra variables --&gt;
    &lt;ui:formListRows&gt;
      &lt;ui:row&gt;

        &lt;ui:cell&gt;
          &lt;!-- Default variable name for accessing the row object is "row" as in
               ordinary lists. This could have been changed by specifying "var" 
               attribute for ui:formListRows tag. --&gt;
          &lt;c:out value="${row.id}"/&gt;
        &lt;/ui:cell&gt;

        ...
        &lt;!-- other cells --&gt;
        ...
        
        &lt;!-- finally, button column --&gt;
        &lt;ui:cell width="0"&gt;
          &lt;c:choose&gt;
            &lt;!-- formRow variable is of class FormRow.ViewModel.
                 It holds the properties of form used to present current row object.
                 Depending on formRow's current status, change button 
                 *(opens the formRow for editing) or *(saves the formRow 
                 already opened). Button title is set accordingly also be set 
                 accordingly. --&gt;
            &lt;c:when test="${formRow.open}"&gt;
              &lt;c:set var="altEditText" value="Save person"/&gt;
            &lt;/c:when&gt;
            &lt;c:otherwise&gt;
              &lt;c:set var="altEditText" value="Edit person"/&gt;
            &lt;/c:otherwise&gt;
          &lt;/c:choose&gt;

          &lt;!-- EditSave event is produced by buttons created with 
               FormListUtil.addEditSaveButtonToRowForm() --&gt;
          &lt;ui:linkButton id="editSave" showLabel="false"&gt;
            &lt;ui:image code="buttonChange" alt="${altEditText}" title="${altEditText}"/&gt;
          &lt;/ui:linkButton&gt;
           &lt;!-- Delete event is produced by buttons created with 
                FormListUtil.addDeleteButtonToRowForm() --&gt;
          &lt;ui:linkButton id="delete" showLabel="false"&gt;
            &lt;ui:image code="buttonDelete" alt="Remove person" title="Remove person"/&gt;
          &lt;/ui:linkButton&gt;
        &lt;/ui:cell&gt;
        
      &lt;/ui:row&gt;
    &lt;/ui:formListRows&gt;

    &lt;!-- Finally the empty form for addition of new objects. --&gt;
    &lt;ui:formListAddForm&gt;
      &lt;ui:row&gt;
        &lt;!-- columns, usage is the same as when rendering a form widget --&gt;
        &lt;ui:cell/&gt;

        &lt;ui:cell styleClass="center"&gt;
          &lt;ui:textInput id="name"/&gt;
        &lt;/ui:cell&gt;

        &lt;ui:cell&gt;
          &lt;ui:textInput id="surname"/&gt;
        &lt;/ui:cell&gt;

        &lt;ui:cell&gt;
          &lt;ui:textInput id="phone"/&gt;
        &lt;/ui:cell&gt;

        &lt;ui:cell&gt;
          &lt;ui:dateInput id="birthdate"/&gt;
        &lt;/ui:cell&gt;

        &lt;ui:cell&gt;
          &lt;ui:floatInput id="salary" styleClass="w40"/&gt;
        &lt;/ui:cell&gt;

        &lt;ui:cell&gt;
          &lt;ui:attribute name="width" value="0"/&gt;
          &lt;ui:linkButton id="add" showLabel="false"&gt;&lt;ui:image code="buttonAdd"/&gt;&lt;/ui:linkButton&gt;
        &lt;/ui:cell&gt;
      &lt;/ui:row&gt;
    &lt;/ui:formListAddForm&gt;

  &lt;/ui:formList&gt;
&lt;/ui:list&gt;
...
</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Anything else?</title>

    <para>Sure. Ask!</para>
  </sect1>
</article>